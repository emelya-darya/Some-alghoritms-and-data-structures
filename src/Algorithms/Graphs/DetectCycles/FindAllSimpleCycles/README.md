# Алгоритм Джонсона (англ. Johnson's algorithm)

__Алгоритм Джонсона__ — алгоритм для нахождения всех простых циклов в ориентированном графе (простой цикл — это цикл, не проходящий дважды через одну вершину). 

<br/>

__Сложность алгоритма:__ 

<p style='margin: 0px; text-align: center; font-weight: 700'>O(V+E)(C+1)</p>

<small>***V, E – количество вершин и рёбер соответственно, С – количество циклов в графе***</small>

_____
#### Принцип работы:

__Для работы алгоритма нужны 2 функции__:
1. ***getAllCyclesWithVrtx*** – вспомогательная функция, которая при помощи [обхода в глубину](../../DFS/) ищет все циклы с участием заданной вершины;
2. ***johnsonsAlg*** – основная функция, которая разбивает переданный граф на [компоненты сильной связности](../../FindSCC/), запускает ***getAllCyclesWithVrtx*** и последовательно удаляет из графа уже обработанные вершины.

<br/>

На вход основной функции ***johnsonsAlg*** подаётся невзвешенная форма графа, на вход ***getAllCyclesWithVrtx*** – компонента сильной связности и имя вершины ***start***, с участием которой будут искаться все циклы.

<br/>

#### Про вспомогательную функцию ***getAllCyclesWithVrtx***:

__Для хранения данных в getAllCyclesWithVrtx инициализируются 6 множеств__:
1. ***outputCycles*** – сет, в который будут складываться все найденные циклы;
2. ***dfsStack*** – стек вершин для определения порядка их посещения при обходе в глубину;
3. ***blockedSet*** – список «заблокированных» вершин, которые DFS в данный момент должен игнорировать;
4. ***blockedMap*** – список вершин, которые могут быть разблокированы попутно с заданной;
5. ***startIndexForNbsCycling*** – множество, куда будут сохранятся индексы для корректной обработки соседей рассмариваемых вершин при обходе в глубину (необходим, т.к. DFS реализован без рекурсии);
6. ***partsOfTheCycles*** – список вершин, которые участвуют в уже найденных циклах.

__Последовательность действий в getAllCyclesWithVrtx:__

1. На старте в ***dfsStack*** и ***blockedSet*** помещаем вершину ***start***;

2. Крутимся в цикле, пока стек ***dfsStack*** не пуст:
   1. Забираем из стека последний элемент ***ТВ*** и получаем его прямых соседей, в которые есть путь из ***ТВ***;
   2. Крутимся по списку соседей в цикле и проверяем каждого соседа ***N*** на наличие в ***blockedSet*** и на равенство вершине ***start*** (на каждой итерации обновляем индекс для последующих циклов по соседям этой же вершины ***ТВ*** в ***startIndexForNbsCycling***):
&nbsp;    - если ***N*** равен ***start***, то кладем содержимое ***dfsStack*** (это и есть цикл) в ***outputCycles*** и сохраняем все вершины из ***dfsStack*** в ***partsOfTheCycles***;
&nbsp;    - если ***N*** нет в ***blockedSet***  – добавляем ***N*** в ***dfsStack*** и ***blockedSet***, а цикл по соседям прерываем(***\*\****);
    3. Если ни для одного из соседей не сработало условие из пункта (***\*\****), то:
&nbsp;    - если ***ТВ*** есть в ***partsOfTheCycles***, то извлекаем ***ТВ*** из ***dfsStack*** и из ***blockedSet*** + проверяем ***blockedMap*** и «разблокируем» (удаляем из ***blockedSet***) вершины, которые могут быть разблокированы вместе с ***ТВ***;   
&nbsp;    - иначе: извлекаем ***ТВ*** из ***dfsStack***, получаем список всех соседей ***ТВ***, которые есть в ***blockedSet***, и для каждого такого соседа в ***blockedMap*** делаем запись о том, что при его «разблокировке» можно «разблокировать» также и ***ТВ***;

3. Возвращаем ***outputCycles***.

<br/>

#### Про основную функцию ***johnsonsAlg***:

__Для хранения данных в johnsonsAlg инициализируются 2 множества__:
1. ***outputCycles*** – массив, в который будут попадать все циклы, найденные с помощью ***getAllCyclesWithVrtx***;
2. ***SCCs*** – компоненты сильной связности текущей формы графа.

__Последовательность действий в johnsonsAlg:__

1. Делаем глубокое копирование переданного графа, сохраняем в переменную ***graph***;

2. Получаем разбиение ***graph*** на компоненты сильной связности (с помощью [алгоритма Тарьяна](../../FindSCC/TarjansAlgorithm/) и [функции, преобразующей области в компоненты сильной связности](../../FindSCC/GetSCCFromSCR/) ), сохраняем это разбиение в ***SCCs***;

2. Крутимся в цикле, пока массив ***SCCs*** не пуст:
    1. Забираем из ***SCCs*** последний элемент ***currSCC***;
    2. Проверяем что ***currSCC*** не образована изолированной вершиной, то есть вершиной, не имеющей ни одного инцидентного ребра в ***currSCC*** (в случае, если это изолированная вершина – удаляем ее из ***graph*** и переходим к следующей итерации цикла); 
    3. Выбираем из ***currSCC*** любой узел ***startVertex*** и запускаем для него ***getAllCyclesWithVrtx***, полученные циклы добавляем в ***outputCycles***;
    4. Удаляем из ***graph*** вершину ***startVertex***;
    5. Делаем для ***graph*** новое разбиение на компоненты сильной связности и сохраняем его в ***SCCs***;

3. Возвращаем ***outputCycles***.


_____
#### Пример работы:
__Задача__: найти все .


<!-- &nbsp;    - если ***N*** нет в ***visited*** вообще – добавляем ***N*** в ***vStack***, ***visited*** (под серым цветом) и ***processedVs***, а цикл по соседям прерываем;
&nbsp;    - если ***N*** есть в ***visited*** под серым цветом – это значит, что цикл найден, работа ***сheckPathsFromOneVrtx*** закончена – возвращаем ***output*** (***\*\****); -->


<!-- 3. Если ни для одного из соседей не сработало ни одно из «если» в предыдущем пункте, то из ***vStack*** извлекаем ***ТВ***, а в ***visited*** помечаем ***ТВ*** черным цветом; -->


<!-- 3. Если функция не прервала свою работу на пункте (***\*\****), возвращаем ***output*** с ***isTheCycleFound*** = false и списком посещенных вершин ***processedVs***. -->

<br/>

<!-- #### Принцип работы:

На вход подается невзвешенная форма графа.

__Для хранения данных потребуется 4 множества__:
- <small>*На уровне области видимости функции инициализируется*:</small>
    1. ***outputCycles*** – массив, в который будут складываться найденные циклы;
    2. ***SCCs*** – список компонент сильной связности текущего графа;
    2. ***reversedTopSort*** – перевернутый массив топологически отсосртированных вершин инвертированного графа;
- <small> *На уровне области видимости цикла, каждая итерация которого запускает DFS для вершины из ***reversedTopSort***, инициализируется:*</small>
    1. ***vStack*** – множество вершин, которые надо обработать, представленное в виде [стека](../../../../DataStructures/Stack/);
    2. ***inTheCurrPath*** – список вершин, которые являются частью пути, по которому сейчас проходит DFS.


<br/>
<br/>

__Последовательность действий:__ -->


<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

<!-- 

__Поиск в глубину__ — один из основных алгоритмов обхода графа, позволяющий получить список всех достижимых вершин графа. Стратегия поиска в глубину, как и следует из названия, состоит в том, чтобы идти «вглубь» графа, насколько это возможно.

На больших графах поиск в глубину серьёзно нагружает стек вызовов. В репозитории представлена нерекурсивная реализация алгоритма на основе [стека](../../../DataStructures//Stack).
 
<br/>

__Сложность алгоритма:__ 

<p style='margin: 0px; text-align: center; font-weight: 700'>O(V+E)</p>

<small>***V, E – количество вершин и рёбер соответственно***</small>

_____
#### Принцип работы:

На вход алгоритма подаётся невзвешенный граф и имя вершины ***reachableFrom***, для которой нужно получить список достижимых из нее вершин (если reachableFrom === null, то будет возвращен список вообще всех достижимых вершин графа). 
В случае, когда нужно применить DFS для взвешенного графа, то можно его привести к виду невзвешенного перед передачей в функцию.
Граф может быть как ориентированным, так и неориентированным — для алгоритма это не важно.

__Для хранения данных инициализируются 2 множества__:
1. ***VrtxsStack*** – множество вершин, которые надо обработать, представленное в виде [стека](../../../DataStructures//Stack);
2. ***ReachableVrtxs*** – список уже посещенных вершин.

<br/>

__Последовательность действий:__

1. На старте в ***vrtxsStack*** и ***reachableVrtxs*** помещаем вершину ***reachableFrom*** (если ***reachableFrom*** === null, то добавляем в оба множества все корневые вершины графа);

2. Крутимся в цикле, пока стек ***vrtxsStack*** не пуст:
   1. Забираем из стека последний элемент ***ТВ*** и получаем его прямых соседей, в которые есть путь из ***ТВ***;
   2. Обрабатываем каждого соседа ***ТВ*** – ***N***. Если ***N*** нет в списке посещенных вершин ***reachableVrtxs***: 
&nbsp;    - добавляем ***N*** в конец стека ***vrtxsStack***;
&nbsp;    - помечаем вершину ***N*** как посещенную - добаляем ее в ***reachableVrtxs***;

3. Возвращаем ***reachableVrtxs***, преобразовав его в массив.

_____
#### Пример работы:
__Задача__: получить список вершин, достижимых из вершины __C__.

Кружками обозначены вершины, линиями – пути между ними (ребра графа). Посещенные вершины помечены красным, рассматриваемая в данный мемент вершина помечается ***ТВ***, соседи ***ТВ*** помечаются синим.

<p align='center'><img  width="500px" src='./images/1.webp' alt='граф'></p>

##### Шаг 1:
Стартовая вершина ***C*** помечается как посещенная (записывается в ***reachableVrtxs***) и добавляется в стек вершин, которые надо рассмотреть ***vrtxsStack***.
Забираем из ***vrtxsStack*** последний элемент – вершину ***C*** – это рассматриваемая вершина (***ТВ***). Прямые соседи ***C***, в которые есть путь из ***C*** – вершины ***D*** и ***E*** – добавляем их в список посещенных ***reachableVrtxs*** и в конец стека ***vrtxsStack***. 

<p align='center'><img width="500px" src='./images/2.webp' alt='граф'></p>

К концу шага:
- в списке посещенных ***reachableVrtxs*** есть [ C, D, E ];
- В очереди вершин, которые нужно посетить ***vrtxsStack*** [ D, E ].

<br/>

##### Шаг 2:
Забираем из ***vrtxsStack*** последний элемент – вершину ***E*** – это рассматриваемая вершина (***ТВ***).
Прямой сосед ***E***, в который есть путь из ***E*** – вершина ***F*** – добавляем ee в список посещенных ***reachableVrtxs*** и в конец стека ***vrtxsStack***. 

<p align='center'><img width="500px" src='./images/3.webp' alt='граф'></p>

К концу шага:
- в списке посещенных ***reachableVrtxs*** есть [ C, D, E, F ];
- В очереди вершин, которые нужно посетить ***vrtxsStack*** [ D, F ].

<br/>

##### Шаг 3:
Забираем из ***vrtxsStack*** последний элемент – вершину ***F*** – это рассматриваемая вершина (***ТВ***).
Прямой сосед ***F***, в который есть путь из ***F*** – вершина ***G*** – добавляем ее в список посещенных ***reachableVrtxs*** и в конец стека ***vrtxsStack***.

<p align='center'><img width="500px" src='./images/4.webp' alt='граф'></p>

К концу шага:
- в списке посещенных ***reachableVrtxs*** есть [ C, D, E, F, G ];
- В очереди вершин, которые нужно посетить ***vrtxsStack*** [ D, G ].

<br/>

##### Шаг 4:
Забираем из ***vrtxsStack*** последний элемент – вершину ***G*** – это рассматриваемая вершина (***ТВ***).
Прямых соседей ***G***, в которые есть путь из ***G***, поэтому переходим к следующему шагу.

<p align='center'><img width="500px" src='./images/5.webp' alt='граф'></p>

К концу шага:
- в списке посещенных ***reachableVrtxs*** есть [ C, D, E, F, G ];
- В очереди вершин, которые нужно посетить ***vrtxsStack*** [ D ].

<br/>

##### Шаг 5:
Забираем из ***vrtxsStack*** последний элемент – вершину ***D*** – это рассматриваемая вершина (***ТВ***).
Прямой сосед ***D***, в который есть путь из ***D*** – вершина ***F*** – уже есть в списке посещенных вершин ***reachableVrtxs***, поэтому никуда ее не добавляем.

<p align='center'><img width="500px" src='./images/6.webp' alt='граф'></p>

__К концу шага стек ***vrtxsStack*** пуст – работа алгоритма окончена.__

_____
#### Источники:
+ [Wikipedia](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83)
+ [IFMO-Wiki](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9E%D0%B1%D1%85%D0%BE%D0%B4_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83,_%D1%86%D0%B2%D0%B5%D1%82%D0%B0_%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD) -->











https://graphonline.ru/?graph=HalinGraph



https://stackoverflow.com/questions/546655/finding-all-cycles-in-a-directed-graph

Про алгоритм джонса
https://www.youtube.com/watch?v=johyrWospv0&t=125s








